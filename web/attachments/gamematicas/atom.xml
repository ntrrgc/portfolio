<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Gamemáticas: algoritmos para videojuegos</title>
  <icon>https://www.gravatar.com/avatar/ac2a25ebc59fcf4600c5fb0f579de66f</icon>
  
  <link href="http://ntrrgc.me/gamematicas/atom.xml" rel="self"/>
  
  <link href="http://ntrrgc.me/gamematicas/"/>
  <updated>2021-01-02T14:00:51.727Z</updated>
  <id>http://ntrrgc.me/gamematicas/</id>
  
  <author>
    <name>Alicia Boya García</name>
    <email>ntrrgc@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Colocar objetos siguiendo formas geométricas, parte 2: polígonos y estrellas</title>
    <link href="http://ntrrgc.me/gamematicas/colocar-objetos-siguiendo-formas-geometricas-parte-2-poligonos-y-estrellas/"/>
    <id>http://ntrrgc.me/gamematicas/colocar-objetos-siguiendo-formas-geometricas-parte-2-poligonos-y-estrellas/</id>
    <published>2015-05-16T20:54:05.000Z</published>
    <updated>2021-01-02T14:00:51.727Z</updated>
    
    <content type="html"><![CDATA[<p>Hace tiempo vimos como <a href="/attachments/gamematicas/colocar-objetos-en-formas-geometricas-parte-1-circunferencia/">colocar objetos en un videojuego siguiendo la forma de una circunferencia</a>. En este artículo vamos a continuar con la serie, explicando cómo colocar objetos para dibujar segmentos (líneas), polígonos y estrellas.</p><h1 id="Colocar-objetos-en-un-segmento"><a href="#Colocar-objetos-en-un-segmento" class="headerlink" title="Colocar objetos en un segmento"></a>Colocar objetos en un segmento</h1><p>Un segmento es una línea recta acotada por un punto de inicio (A) y un punto de fin (B). Para colocar objetos en un segmento lo dividiremos en un cierto número de partes iguales.</p><p><img src="/attachments/gamematicas/images/divisiones.svg" alt="Un segmento dividido en cuatro partes iguales"></p><p>Como podemos ver en el ejemplo anterior, dividiendo el segmento en cuatro partes obtenemos cinco puntos equidistantes donde colocar nuestros objetos. </p><p>Nuestros puntos vienen dados por una posición $x$ (horizontal) y una posición $y$ (vertical). Restando la posición $x$ de B con la posición $x$ de A obtenemos el <em>ancho</em> del segmento, que podría ser negativo si B estuviera a la izquierda de A. De forma similar, restando las posiciones $y$ obtenemos el <em>alto</em> del segmento.</p><p>Dividiendo el ancho y el alto entre un número de partes (en el ejemplo, cuatro) obtendremos el ancho y el alto de cada parte.</p><p>Nuestros puntos equidistantes se obtendrán sumando a A el tamaño de una parte entre cero y cuatro veces (el número de partes). A continuación se muestra un ejemplo de cómo se podría implementar este algoritmo.</p><pre><code>function drawSegment(ax, ay, bx, by, numPoints) &#123;  // Calculamos el alto y ancho del segmento  var w = bx - ax;  var h = by - ay;  // Calculamos el alto y ancho de las partes  var numParts = numPoints - 1;  var partW = w / numParts;  var partH = h / numParts;  // Para i entre 0 y `numPoints` (no incluido) ...  for (var i = 0; i &lt; numPoints; i++) &#123;    // Dibujamos un punto que será A sumado i    // veces el ancho y alto de la parte.    drawPoint(&#123;      x: ax + partW * i,      y: ay + partH * i    &#125;);  &#125;&#125;</code></pre><h1 id="Poligonos-regulares"><a href="#Poligonos-regulares" class="headerlink" title="Polígonos regulares"></a>Polígonos regulares</h1><p>Un polígono es un conjunto de segmentos unidos entre sí. En general, todo segmento tiene un punto de inicio y un punto de fin. En el caso de un polígono, el punto de inicio de un segmento es el punto de fin del anterior.<br>Aquí vamos a centrarnos en los polígonos regulares, es decir, aquellos que todos los segmentos que los forman tienen la misma longitud, puesto que son los que utilizaremos después como base para hacer estrellas.</p><p>Un polígono regular se construye a partir de una circunferencia, dividiéndola en tantos arcos como lados queramos para nuestro polígono. Todos los arcos deben tener el mismo ángulo. La siguiente imagen muestra como ejemplo la construcción de un pentágono.</p><p><img src="/attachments/gamematicas/images/pentagono.svg" alt="El pentágono se construye dividiendo una circunferencia en cinco arcos iguales y uniendo los puntos de corte"></p><p>El proceso para obtener estos puntos <a href="/colocar-objetos-en-formas-geometricas-parte-1-circunferencia/#Colocar_objetos_alrededor_del_c%C3%ADrculo">es exactamente el mismo que veíamos para representar un círculo en el artículo anterior</a>. Dividimos el ángulo de la circunferencia completa ($2\pi$ radianes o 360º) entre el número de lados y utilizamos seno y coseno para calcular los puntos que definen el polígono.</p><pre><code>function calcPolygonVertices(numVertices, centerX,                             centerY, radius, rotation)&#123;  // Dividimos el ángulo de la circunferencia completa   // (2pi=360°) entre el número de vértices del polígono.  // De esta manera obtendremos el ángulo de los lados.  var angInterval = 2 * Math.PI / numVertices;  // Inicializamos una lista de vértices  var vertices = [];  for (var i = 0; i &lt; numVertices; i++) &#123;    // Multiplicamos el número de vértice por el ángulo     // de los lados    var x = centerX +         Math.cos(i * angInterval + rotation) * radius;    var y = centerY +        Math.sin(i * angInterval + rotation) * radius;    vertices.push(&#123;x: x, y: y&#125;);  &#125;  return vertices;&#125;</code></pre><p>Sin embargo, en este caso no nos conformaremos con pintar los puntos, sino que los utilizaremos de entrada para la función anterior de manera que podamos dibujar segmentos.</p><pre><code>function drawPolygon(numVertices, centerX, centerY, radius,                     rotation, numPointsSegment)&#123;  var vertices = calcPolygonVertices(numVertices, centerX,      centerY, radius, rotation);  // Unimos cada vértice con el siguiente  for (var numVertex = 0; numVertex &lt; numVertices;       numVertex++)  &#123;    var vertexA = vertices[numVertex];    var vertexB = vertices[numVertex + 1];    drawPolygonSegment(vertexA.ax, vertexA.ay,                       vertexB.ax, vertexB.ay,                       numPointsSegment);  &#125;&#125;</code></pre><p>La función <code>drawPolygonSegment</code> es igual que la función <code>drawSegment</code> explicada antes, con una sutil diferencia: el último punto del segmento no es dibujado, ya que coincidirá con el primer punto del siguiente lado del polígono. </p><pre><code>function drawPolygonSegment(ax, ay, bx, by, numPoints) &#123;  // Calculamos el alto y ancho del segmento  var w = bx - ax;  var h = by - ay;  // Calculamos el alto y ancho de las partes  var numParts = numPoints - 1;  var partW = w / numParts;  var partH = h / numParts;  // Para i entre 0 y `numPoints - 1` (no incluido) ...  // El último punto no se dibuja porque coincide con  // el primer punto del siguiente segmento  for (var i = 0; i &lt; numPoints - 1; i++) &#123;    // Dibujamos un punto que será A sumado i    // veces el ancho y alto de la parte.    drawPoint(&#123;      x: ax + partW * i,      y: ay + partH * i    &#125;);  &#125;&#125;</code></pre><div class="demo" data-demo-name="star" data-demo-tag="polygon">  <header class="phone">Demostración en vivo</header>  <div class="demo-wrapper">    <div class="canvas-wrapper">      <canvas width="300" height="200"></canvas>    </div>    <noscript>La demostración en vivo no funciona sin JavaScript :(</noscript>    <div class="controls-wrapper">      <header class="non-phone">Demostración en vivo</header>      <div class="demo-controls"></div>    </div>  </div></div><h2 id="Hacer-los-poligonos-animables"><a href="#Hacer-los-poligonos-animables" class="headerlink" title="Hacer los polígonos animables"></a>Hacer los polígonos animables</h2><p>Añadiendo un desplazamiento a la posición de los puntos utilizados para dibujar los segmentos y modificando su valor a lo largo del tiempo es posible mostrar polígonos animados, donde los objetos no estén colocados en posiciones estáticas  sino que se muevan siguiendo la forma del polígono.</p><p>El desplazamiento se especificará como una variable numérica entre 0 y 1. Un valor de 0 será sinónimo de no desplazamiento, mientras con valor de 1 significará que el primer punto estaría en la posición en la que habría estado el segundo si no se hubiera aplicado desplazamiento.</p><p>El siguiente bloque de código muestra la función de dibujado de segmentos de polígonos adaptada para soportar desplazamiento. Es similar a la anterior, pero añadimos un nuevo parámetro <code>offset</code> y  y se lo sumamos al número de punto.</p><pre><code>function drawPolygonSegment(ax, ay, bx, by, numPoints,                            offset)&#123;  // Calculamos el alto y ancho del segmento  var w = bx - ax;  var h = by - ay;  // Calculamos el alto y ancho de las partes  var numParts = numPoints - 1;  var partW = w / numParts;  var partH = h / numParts;  // Para i entre 0 y `numPoints - 1` (no incluido) ...  // El último punto no se dibuja porque coincide con  // el primer punto del siguiente segmento  for (var i = 0; i &lt; numPoints - 1; i++) &#123;    // Dibujamos un punto que será A sumado i    // veces el ancho y alto de la parte.    drawPoint(&#123;      x: ax + partW * (i + offset),      y: ay + partH * (i + offset)    &#125;);  &#125;&#125;</code></pre><p>Sólo quedaría añadir este parámetro también a la función de dibujar polígono y modificar su valor en cada frame.</p><h1 id="Estrellas"><a href="#Estrellas" class="headerlink" title="Estrellas"></a>Estrellas</h1><p>A partir de un polígono regular, es fácil construir una estrella. Para ello se sigue el mismo procedimiento que en el caso del polígono, con una diferencia: Cada vértice del polígono será unido con el que esté a $n \geq 2$ posiciones después de él. A este $n$ lo denominaremos el <em>paso</em> de la estrella.</p><p>En la siguiente figura se muestra la construcción de una estrella de cinco puntas con paso 2:</p><p><img src="/attachments/gamematicas/images/pentagrama.svg" alt="Una estrella de cinco puntas dibujada a partir de un polígono"></p><p>El siguiente algoritmo nos permitiría construir una estrella de este tipo:</p><pre><code>function drawStar(numVertices, centerX, centerY, radius,                  rotation, numPointsSegment, starStep,                  segmentOffset)&#123;  var vertices = calcPolygonVertices(numVertices, centerX,      centerY, radius, rotation);  // Una estrella tiene el doble de segmentos que vértices  var numSegments = vertices.length * 2;  var indexVertexA = 0; // Empezamos trazando desde el                        // vértice 0  for (var i = 0; i &lt; numSegments; i++) &#123;    // El vértice destino del segmento es aquel que esté a    // `starStep` posiciones del vértice de origen    var indexVertexB = (indexVertexA + starStep)        % vertices.length;    // Dibujamos el segmento    var vertexA = vertices[indexVertexA];    var vertexB = vertices[indexVertexB];    drawPolygonSegment(vertexA.ax, vertexA.ay,        vertexB.ax, vertexB.ay,        numPointsSegment, segmentOffset);    // El vértice destino de este segmento será el vértice    // inicio del siguiente    indexVertexA = indexVertexB;  &#125;&#125;</code></pre><h2 id="Estrellas-no-conectadas"><a href="#Estrellas-no-conectadas" class="headerlink" title="Estrellas no conectadas"></a>Estrellas no conectadas</h2><p>Con el algoritmo anterior no es posible dibujar algunos tipos de estrellas. Es el caso de la estrella de seis puntas o hexagrama, mostrada en la figura siguiente.</p><p><img src="/attachments/gamematicas/images/hexagrama.svg" alt="Estrella de seis puntas"></p><p>Al dibujar la estrella de seis puntas con un paso de dos, nos encontramos con que de después de tres pasos volvemos a al vértice inicial. Los segmentos de la estrella de seis puntas, no están todos conectados. </p><p>Cuando se dé este caso, para terminar la estrella deberemos repetir el proceso desde el vértice siguiente a aquel en el que empezamos. </p><p>El siguiente fragmento de código muestra cómo dibujar una estrella de forma que se tenga en cuenta el caso de que haya grupos de segmentos desconectados. </p><pre><code>function drawStar(numVertices, centerX, centerY, radius,                  rotation, numPointsSegment, starStep,                  segmentOffset)&#123;  var vertices = calcPolygonVertices(numVertices,      centerX, centerY, radius, rotation);  // Una estrella tiene el doble de segmentos que  // vértices  var numSegments = vertices.length * 2;  // Empezamos trazando desde el vértice 0  var indexStartVertex = 0;  var indexVertexA = indexStartVertex;  for (var i = 0; i &lt; numSegments; i++) &#123;    // El vértice destino del segmento es aquel que esté    // a `starStep` posiciones del vértice de origen    var indexVertexB = (indexVertexA + starStep)        % vertices.length;    // Dibujamos el segmento    var vertexA = vertices[indexVertexA];    var vertexB = vertices[indexVertexB];    drawPolygonSegment(vertexA.ax, vertexA.ay,        vertexB.ax, vertexB.ay,        numPointsSegment, segmentOffset);    // El vértice destino de este segmento será el    // vértice inicio del siguiente    indexVertexA = indexVertexB;    // Si volvemos al punto de inicio y todavía quedan    // más pasos, estamos ante una estrella desconectada.    // Deberemos repetir el proceso empezando a dibujar    // por el punto siguiente.    if (indexVertexA == indexStartVertex) &#123;      indexStartVertex = (indexStartVertex + 1)          % vertices.length;      indexVertexA = indexStartVertex;    &#125;  &#125;&#125;</code></pre><h2 id="Demostracion"><a href="#Demostracion" class="headerlink" title="Demostración"></a>Demostración</h2><p>La siguiente demo muestra la construcción de una estrella haciendo uso de los algoritmos explicados.</p><div class="demo" data-demo-name="star" data-demo-tag="star-construction">  <header class="phone">Demostración en vivo</header>  <div class="demo-wrapper">    <div class="canvas-wrapper">      <canvas width="300" height="200"></canvas>    </div>    <noscript>La demostración en vivo no funciona sin JavaScript :(</noscript>    <div class="controls-wrapper">      <header class="non-phone">Demostración en vivo</header>      <div class="demo-controls"></div>    </div>  </div></div><h2 id="Animacion"><a href="#Animacion" class="headerlink" title="Animación"></a>Animación</h2><p>Podemos modificar en cada frame los valores algunos parámetros de la función <code>drawStar</code> para crear animaciones:</p><ul><li><code>rotation</code> define la rotación global de la estrella. Con un valor de cero el primero vértice de la estrella está situado en la parte derecha de la circunferencia (0°). Modificando este valor periódicamente podemos conseguir que la estrella gire. </li><li><code>segmentOffset</code> define el desplazamiento de los objetos utilizados para dibujar los segmentos de la estrella. Modificando periódicamente este valor entre cero y uno conseguiremos que los objetos que utilicemos para usemos para dibujar la estrella no estén situados estáticamente sino que sigan la forma de la estrella.</li><li><code>radius</code> define el radio de la circunferencia sobre la que se inscribe la estrella. Animando el valor de esta variable podemos hacer que crezca o decrezca.</li><li><code>centerX</code> y <code>centerY</code> definen la posición de la estrella. Animando estos valores podemos hacer que se mueva por la pantalla.</li></ul><p>La siguiente demostración permite animar alguno de de estos valores:</p><div class="demo" data-demo-name="star" data-demo-tag="star-animation">  <header class="phone">Demostración en vivo</header>  <div class="demo-wrapper">    <div class="canvas-wrapper">      <canvas width="300" height="200"></canvas>    </div>    <noscript>La demostración en vivo no funciona sin JavaScript :(</noscript>    <div class="controls-wrapper">      <header class="non-phone">Demostración en vivo</header>      <div class="demo-controls"></div>    </div>  </div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Hace tiempo vimos como &lt;a href=&quot;/attachments/gamematicas/colocar-objetos-en-formas-geometricas-parte-1-circunferencia/&quot;&gt;colocar objetos e</summary>
      
    
    
    
    <category term="Geometría" scheme="http://ntrrgc.me/gamematicas/categorias/Geometria/"/>
    
    
    <category term="trigonometría" scheme="http://ntrrgc.me/gamematicas/tags/trigonometria/"/>
    
    <category term="colocación de objetos" scheme="http://ntrrgc.me/gamematicas/tags/colocacion-de-objetos/"/>
    
    <category term="geometría" scheme="http://ntrrgc.me/gamematicas/tags/geometria/"/>
    
    <category term="polígonos" scheme="http://ntrrgc.me/gamematicas/tags/poligonos/"/>
    
  </entry>
  
  <entry>
    <title>Normalizar ángulos</title>
    <link href="http://ntrrgc.me/gamematicas/normalizar-angulos/"/>
    <id>http://ntrrgc.me/gamematicas/normalizar-angulos/</id>
    <published>2015-05-14T07:44:35.000Z</published>
    <updated>2021-01-02T13:35:27.278Z</updated>
    
    <content type="html"><![CDATA[<p>En ocasiones tenemos un ángulo que nos determina la rotación de un objeto y necesitamos actualizarlo girando en un sentido u en otro. La forma más simple de actualizar este ángulo es sumando o restando otro valor que nos indique cuánto queremos girar el objeto.</p><p>Esta manera de actualizar ángulos, aunque es simple, tiene un pequeño defecto: si seguimos girando en el mismo sentido continuamente el ángulo resultante tendrá un valor muy grande. </p><p>Si bien, matemáticamente un ángulo muy grande equivalente a uno más pequeño de cero y 360°, hay varias razones por la que nos podría interesar limitar el valor del ángulo a este rango:</p><ul><li><p>Si como parte de la interfaz de nuestro juego queremos mostrar el valor de un ángulo, sería poco conveniente mostrar un ángulo no normalizado, por ejemplo 3630°, en vez del ángulo normalizado equivalente (en el ejemplo, 30°).</p></li><li><p>La precisión de los ordenadores a la hora de trabajar con números decimales es limitada, y al llegar a valores muy grandes descartan las cifras menos significativas. Si incrementamos el valor de un ángulo una y otra vez sin normalizarlo llegará un momento en el que el valor sea tan grande que los incrementos que se hagan tendrán una precisión reducida o incluso dejarán de tener efecto. </p><p>Por ejemplo, sumar 10.000.000 + 1 en una variable <em>float</em> de 32 bits devuelve 10.000.000 porque la variable no tiene espacio suficiente para almacenar el número entero. </p><p>Teniendo en cuenta que en una variable <em>float</em>, de los 32 bits disponibles, 23 bits se utilizan para guardar la parte fraccionaria (<a href="http://es.wikipedia.org/wiki/IEEE_coma_flotante">referencia</a>) y que para representar un ángulo con precisión capaz de distinguir 512 valores necesitamos 9 bits, empezaríamos a tener problemas tras girar nuestro objeto $2^{(23-9)}=2^{14}= 16.384$ vueltas, suponiendo que ha partido de un valor de cero. Si consideramos que esto puede suceder, nos interesará normalizar los ángulos para evitarlo.</p></li></ul><h1 id="Algoritmo-de-normalizacion"><a href="#Algoritmo-de-normalizacion" class="headerlink" title="Algoritmo de normalización"></a>Algoritmo de normalización</h1><p>En primer lugar estudiaremos el algoritmo de normalización en genérico, de manera que nos pueda servir para cualquier variable cíclica. Después la especializaremos para grados y radianes.</p><h2 id="Variables-ciclicas"><a href="#Variables-ciclicas" class="headerlink" title="Variables cíclicas"></a>Variables cíclicas</h2><p>Entenderemos una variable cíclica como aquella en la que existe un rango normal de valores (definido por un mínimo y un máximo $[min,max)$) y en la un valor fuera del rango normal es funcionalmente equivalente a ese mismo valor sumado o restado la amplitud del rango ($max - min$) un número entero de veces.</p><p>Un ejemplo cotidiano de variable cíclica es el reloj de 12 horas: las 11 + 4 horas son las 15, cuyo valor normalizado es $15-12=3$ (las 3).</p><p>Un aspecto a destacar es que el máximo del rango de una variable cíclica, por definición, no es un valor normalizado. Por ejemplo, si nuestro rango es $[0^{\circ}, 360^{\circ})$, el valor normalizado de 360° es 0°.</p><h2 id="Proceso-de-normalizacion"><a href="#Proceso-de-normalizacion" class="headerlink" title="Proceso de normalización"></a>Proceso de normalización</h2><p>Seguiremos utilizando el ejemplo del reloj de 12 horas. En la figura siguiente se ven representados sobre una línea el el rango de valores normal y un valor <code>val</code> que intentaremos normalizar. Una hora normalizada tiene cualquier valor entre 1 y 13, con el 13 no incluido (1:00 es una hora normalizada y 12:59 también).</p><p><img src="/attachments/gamematicas/images/normalizar2.svg"></p><p>En primer lugar desplazaremos todos los valores de manera que el rango comience en cero.</p><p><img src="/attachments/gamematicas/images/normalizar2.svg"></p><p>El proceso seguir después, depende de si $val - min$ es positivo o negativo.</p><h3 id="Si-es-positivo"><a href="#Si-es-positivo" class="headerlink" title="Si es positivo"></a>Si es positivo</h3><p>En el caso de que $val - min$ sea positivo, estará a la derecha del cero en nuestra representación. Calculamos el resto de la división de $val - min$ entre la amplitud ($max - min$). </p><p><img src="/attachments/gamematicas/images/normalizar3.svg"></p><p> $a\ %\ b$ denota el resto obtenido al hacer la división de $a$ entre $b$.</p><p>Con esto hemos conseguido ajustar el valor de $val$ entre 0 y 12. pero nuestro rango inicial era entre 1 y 13. Sumando el mínimo (1) obtenemos el valor deseado.</p><p>$$normalizar(val, min, max)\ |\ val \geq min \\ = min + (val - min)\ %\ (max - min)$$</p><h3 id="Si-es-negativo"><a href="#Si-es-negativo" class="headerlink" title="Si es negativo"></a>Si es negativo</h3><p>En el caso de que $val - min$ sea positivo, estará a la izquierda del cero en nuestra representación, como podemos ver en la siguiente figura.</p><p><img src="/attachments/gamematicas/images/normalizar4.svg"></p><p>Podemos alternar el signo dando la vuelta a los operandos de la resta y operar como en el caso de que fuera positivo. </p><p>$$-(val - min)\<br>= -val -(-min) \<br>=min - val$$</p><p><img src="/attachments/gamematicas/images/normalizar5.svg"></p><p>El resultado es correcto, pero está invertido debido al cambio de signo. Podemos corregir esto restando a la amplitud $(max - min)$ el valor calculado.</p><p><img src="/attachments/gamematicas/images/normalizar6.svg"></p><p>Finalmente, igual que en el caso de los valores positivos, sumamos $min$ para obtener una hora entre 1 y 13.</p><p>$$normalizar(val, min, max)\ |\ val \lt min \\ = min + (max - min) \\ - ((min - val) %\ (max - min))$$</p><p>$min-min$ se anula y queda…</p><p>$$normalizar(val, min, max)\ |\ val \lt min \\ = max - ((min - val)\ %\ (max - min))$$</p><h2 id="Formula-y-codigo"><a href="#Formula-y-codigo" class="headerlink" title="Fórmula y código"></a>Fórmula y código</h2><p>Juntando los dos casos anteriores, esta es la definición matemática de nuestra función de normalización:</p><p>$$normalizar(val, min, max)\ |\ val \lt min \\ = min + (max - min) \\ - ((min - val)\ %\ (max - min))$$</p><p>En código:</p><pre><code>function normCyclic(val, min, max) &#123;   if (val &gt;= min) &#123;     return min + (val - min) % (max - min);   &#125; else &#123;     return max - (min - val) % (max - min);   &#125;&#125;</code></pre><p>Con esta función podemos normalizar cualquier varible cíclica. Para terminar el ejemplo, la siguiente función normalizaría tiempo en formato de 12 horas.</p><pre><code>function norm12Hours(val) &#123;  return normCyclic(val, 1, 13);&#125;</code></pre><h1 id="Normalizar-angulos-en-distintos-formatos"><a href="#Normalizar-angulos-en-distintos-formatos" class="headerlink" title="Normalizar ángulos en distintos formatos"></a>Normalizar ángulos en distintos formatos</h1><p>Teniendo nuestra función de normalización, es trivial construir funciones que normalizen variables cíclicas de distinto tipo.</p><h2 id="Normalizar-radianes"><a href="#Normalizar-radianes" class="headerlink" title="Normalizar radianes"></a>Normalizar radianes</h2><p>Esta función normaliza grados medidos en radianes dentro del rango $[-\pi,\pi)$. Podemos utilizarla para actualizar variables de giro sin miedo a que se produzca pérdida de precisión.</p><pre><code>function normRad(val) &#123;  return normCyclic(val, -Math.PI, Math.PI);&#125;</code></pre><p>Para actualizar una variable de rotación realizando normalización utilizaríamos un código como este:</p><pre><code>function update() &#123;  var rotSpeed = 3; // rad/s  // Actualiza la rotación del objeto teniendo  // sumándole la velocidad angular.  this.rotation = normRad(this.rotation + rotSpeed);&#125;</code></pre><h2 id="Normalizar-grados"><a href="#Normalizar-grados" class="headerlink" title="Normalizar grados"></a>Normalizar grados</h2><p>De forma similar podemos normalizar grados. Podemos utilizar el rango $[0^{\circ}, 360^{\circ})$, con lo que obtendríamos sólo números positivos, o $[-180^{\circ}, 180^{\circ})$ si queremos tener ángulos tanto positivos como negativos.</p><pre><code>function normDeg360(val) &#123;  return normCyclic(val, 0, 360);&#125;function normDeg180(val) &#123;  return normCyclic(val, -180, 180);&#125;</code></pre><h1 id="Cuando-no-normalizar-variables-angulares"><a href="#Cuando-no-normalizar-variables-angulares" class="headerlink" title="Cuando no normalizar variables angulares"></a>Cuando no normalizar variables angulares</h1><p>Cuando definimos al principio de la definición del algoritmo las variables cíclicas especificamos una restricción:</p><blockquote><p>Entenderemos una variable cíclica como aquella en la que existe un rango normal de valores (definido por un mínimo y un máximo $[min,max)$) y en la <strong>un valor fuera del rango</strong> normal es <strong>funcionalmente equivalente</strong> a ese mismo valor sumado o restado la amplitud del rango ($max - min$) un número entero de veces.</p></blockquote><p>En una variable de rotación la condición de equivalencia es cierta. Por ejemplo, un elemento rotado 540° produce el mismo resultado que rotando 180°: el elemento aparece girado media vuelta.</p><p>Sin embargo, hay otras variables en la que hay una diferencia muy importante. Es el caso de las variables de velocidad angular y aceleración angular: que un objeto gire 540°/s no produce el mismo efecto que si gira a 180°/s. En el primer caso da una vuelta completa y media en un segundo, mientras en el segundo caso, en el mismo tiempo, sólo recorre media vuelta.</p><p>La normalización de ángulos es útil para evitar condiciones inesperadas en nuestro código, así como mostrar valores al usuario en un rango razonable, pero no debe usarse de forma compulsiva en toda variable angular.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;En ocasiones tenemos un ángulo que nos determina la rotación de un objeto y necesitamos actualizarlo girando en un sentido u en otro. La </summary>
      
    
    
    
    <category term="Geometría" scheme="http://ntrrgc.me/gamematicas/categorias/Geometria/"/>
    
    
    <category term="geometría" scheme="http://ntrrgc.me/gamematicas/tags/geometria/"/>
    
  </entry>
  
  <entry>
    <title>El tiro parabólico en 2D</title>
    <link href="http://ntrrgc.me/gamematicas/el-tiro-parabolico-en-2d/"/>
    <id>http://ntrrgc.me/gamematicas/el-tiro-parabolico-en-2d/</id>
    <published>2015-02-23T14:19:41.000Z</published>
    <updated>2021-01-02T02:20:51.529Z</updated>
    
    <content type="html"><![CDATA[<p>En muchos juegos se necesita en algún momento lanzar proyectiles. En esta guía exploraremos la física detrás de estos tiros de cara a realizar una implementación sencilla de tiros parabólicos sin necesitar bibliotecas de física especializadas.</p><p>Para empezar con algo simple, consideremos que nuestro juego tiene dos dimensiones: altura y profundidad.</p><h2 id="Introduccion-a-los-vectores"><a href="#Introduccion-a-los-vectores" class="headerlink" title="Introducción a los vectores"></a>Introducción a los vectores</h2><p>En física, a menudo se encuentran casos donde una magnitud (cantidad) y una dirección están intimamente relacionadas a la hora de describir un fenómeno. Un ejemplo clásico es la velocidad: es tan importante la magnitud de la velocidad de un coche (habitualmente medida en km/h) como en qué dirección se está moviendo.</p><p>Cuando se dan estas relaciones es habitual tratar magnitud y dirección de manera conjunta. Cuando una variable matemática representa estos dos conceptos simultáneamente, se le denomina vector y se representa colocando una flecha encima del nombre de la variable, por ejemplo, $\vec{v}$.</p><p>Hay dos formas habituales de expresar el valor de un vector. Una forma es indicar la magnitud y la dirección (ángulo) expresamente. Por ejemplo:</p><p>$$\vec{v} = 100_{60^{\circ}}\space km/h$$</p><p>Esta fórmula representaría la velocidad de un coche que se mueve a 100 km/h en dirección 60º. (medidos con respecto a un ángulo que consideremos origen, por ejemplo el Norte geográfico y en un determinado sentido). Cuando usemos ángulos en vectores debemos tener en cuenta siempre qué dirección consideraremos como referencia y en qué sentido haremos la medición. Por ejemplo, en este caso podríamos considerar que el ángulo se mide en grados desde el Norte geográfico hasta la posición a medir girando en sentido de las agujas del reloj.</p><p>En matemáticas, una convención habitual es considerar que 0º es el plano horizontal y los ángulos positivos están en el sentido contrario a las agujas del reloj, por ejemplo:</p><p><img src="/attachments/gamematicas/images/angulo.svg" alt="Una imagen de un vector con el suelo como referencia"></p><p>Otra forma de expresar un vector es descomponer magnitud y dirección en coordenadas. Por ejemplo:</p><p>$$\vec{v} = (30, 50)\space km/h$$</p><p>En este caso estaríamos representando la velocidad de un coche que cada hora avanza 30 km en el eje horizontal (x) y 50 km en el eje vertical (y). Los ejes horizontal y vertical se pueden representar también como vectores, habitualmente con los nombres $\vec{i}$ y $\vec{j}$ para los ejes $x$ e $y$ respectivamente. Por ejemplo, el mismo vector anterior se podría representar como:</p><p>$$\vec{v} = 30\vec{i} + 50\vec{j}\space km/h$$</p><p>Cada representación tiene sus ventajas e inconvenientes. En nuestros ejemplos utilizaremos la representación de coordenadas, con una variable por coordenada, por ejemplo: <code>velX</code>, <code>velY</code>. En esta representación es muy fácil sumar vectores.</p><h2 id="Objetos"><a href="#Objetos" class="headerlink" title="Objetos"></a>Objetos</h2><p>Para incorporar física en nuestros objetos debemos añadirles propiedades que reflejen el estado de todas las variables físicas que sean de nuestro interés. En este caso necesitamos, como mínimo:</p><ul><li>Posición (x, y): Dónde está el objeto en este momento.</li><li>Velocidad (vector): Hacia dónde se mueve el objeto y cómo de rápido lo hace.</li></ul><p>Cada objeto de nuestro juego deberá tener una función de actualización donde sus variables físicas sean actualizadas. Esta función será ejecutada de manera periódica, típicamente una vez por frame.</p><p>En nuestro ejemplo, la función de actualización se encargaría de actualizar la posición en función de la velocidad. Si la velocidad del objeto es 2 píxels por frame y la función de actualización se ejecuta cada frame, deberá sumarse 2 a la posición del objeto.</p><pre><code>function update() &#123;  this.posX = this.posX + this.velX;  this.posY = this.posY + this.velY;&#125;</code></pre><h2 id="Lanzar-un-proyectil"><a href="#Lanzar-un-proyectil" class="headerlink" title="Lanzar un proyectil"></a>Lanzar un proyectil</h2><p>Lanzar un proyectil consiste en aplicarle una velocidad. </p><p>Sin ninguna fuerza que modifique la trayectoria del proyectil, éste se moverán línea recta. </p><p>Es posible que en este paso necesitemos convertir una velocidad expresada en magnitud y dirección a formato de componentes $x$ e $y$. Para ello podemos hacer uso de trigonometría básica:</p><pre><code>function shoot(speedMagnitude, speedDirection) &#123;    this.velX += speedMagnitude * Math.cos(speedDirection);    this.velY += speedMagnitude * Math.sin(speedDirection);&#125;</code></pre><h2 id="Gravedad"><a href="#Gravedad" class="headerlink" title="Gravedad"></a>Gravedad</h2><p>En el mundo real, los objetos en movimiento están sometidos a fuerzas, que los aceleran en determinadas direcciones. Particularmente, la gravedad cada usa que los proyectiles caigan.</p><p>Para objetos en la Tierra de una masa pequeña comparada a la de un planeta, la aceleración causada por la gravedad es constante y conocida: 9,8 $m/s^2$. </p><p>Esto significa que cada segundo, la velocidad del objeto se incrementa en 9,8 $m/s$ (metros por segundo) en dirección al centro de la Tierra. Cuanto más tiempo lleva cayendo, más rápido cae.</p><p>Por supuesto este movimiento cesa cuando el objeto llega al suelo. (Realmente la gravedad sigue haciendo su trabajo, pero aparece una fuerza de tensión en sentido contrario ejercida por el suelo que causa que el objeto no se hunda.) </p><p>Debemos tener en cuenta esto en nuestros programas para que nuestros objetos no caigan al eternamente al vacío (salvo que sea eso exactamente lo que queramos). </p><p>Para tener en cuenta la gravedad  modificaremos la velocidad en nuestra función de actualización. Por ejemplo:</p><pre><code>function update() &#123;    //En este ejemplo asumimos que y=0 es el suelo y las    // y&#39;s positivas están encima del suelo.    // La gravedad modifica la velocidad del objeto,    // siempre que no esté en el suelo.    if (this.y &gt; 0) &#123;        var gravity = 9.8; // píxels/frame²        this.velY = this.velY - gravity;    &#125;    // Movemos el objeto de acuerdo a su velocidad.    this.posX = this.posX + this.velX;    // Utilizamos la función máximo para que el objeto    // no pueda caer a una posición subterránea.    this.posY = Math.max(this.posY + this.velY, 0);&#125;</code></pre><h2 id="Demostracion"><a href="#Demostracion" class="headerlink" title="Demostración"></a>Demostración</h2><p>En la siguiente demo se muestran una pequeña aplicación del tiro parabólico.</p><div class="demo" data-demo-name="projectile" data-demo-tag="">  <header class="phone">Demostración en vivo</header>  <div class="demo-wrapper">    <div class="canvas-wrapper">      <canvas width="300" height="200"></canvas>    </div>    <noscript>La demostración en vivo no funciona sin JavaScript :(</noscript>    <div class="controls-wrapper">      <header class="non-phone">Demostración en vivo</header>      <div class="demo-controls"></div>    </div>  </div></div><h2 id="Extra-Rotacion-de-proyectiles"><a href="#Extra-Rotacion-de-proyectiles" class="headerlink" title="Extra: Rotación de proyectiles"></a>Extra: Rotación de proyectiles</h2><p>Muchos proyectiles, por su forma aerodinámica, giran sobre sí mismos conforme avanzan en su trayectoria. Es el caso de las flechas empleadas en la demostración anterior. Si no fuera por esta rotación, el movimiento sería algo extraño, como en la imagen siguiente:</p><p><img src="/attachments/gamematicas/images/sin-rotacion.png" alt="Flechas siendo arrojadas sin describir ninguna rotación"></p><p>En lugar de eso queremos algo así, como vimos en la demo:</p><p><img src="/attachments/gamematicas/images/con-rotacion.png" alt="Flechas siendo arrojadas y modificando su rotación con la trayectoria"></p><p>Afortunadamente, este efecto es fácil de simular. Observa la siguiente ilustración de la posible trayectoria de una flecha. </p><p><img src="/attachments/gamematicas/images/inclinacion.svg" alt="Aparece una línea curva con círculos rosados colocados en intervalos regulares"></p><p>Los círculos rosados señalan los puntos de la trayectoria que realmente aparecerían en nuestro juego. Aunque en teoría la trayectoria tiene infinitos puntos, nuestro juego tendrá que conformarse con representar sólo algunos. Esto es lo que hacemos cuando actualizamos la posición de nuestros objetos sólo 60 veces por segundo. Por supuesto, en la imagen este efecto está muy exagerado.</p><p>Si trazamos una línea entre dos puntos consecutivos obtendremos la inclinación que queremos para nuestro proyectil cuando se halle sobre uno de esos puntos de forma bastante precisa. A mayor sea la resolución (más cerca estén esos puntos), mayor será la precisión.</p><p>Habiendo visto esto, el procedimiento es muy fácil. Sólo necesitamos conocer cómo ha cambiado nuestra posición durante el frame actual, o dicho de otro modo, en qué dirección nos estamos moviendo. Esto nos lo da el vector velocidad.</p><p><img src="/attachments/gamematicas/images/inclinacion2.svg" alt="Sobre la imagen anterior se han unido dos puntos mediante un triángulo rectángulo"></p><p>Teniendo un vector que indica nuestra dirección, es muy fácil extraer su ángulo utilizando razones trigonométricas. El ángulo del vector velocidad será el ángulo de rotación de nuestro proyectil.</p><h3 id="Calculo-del-angulo-de-un-vector"><a href="#Calculo-del-angulo-de-un-vector" class="headerlink" title="Cálculo del ángulo de un vector"></a>Cálculo del ángulo de un vector</h3><p>El ángulo de un triángulo representado arriba se determina mediante la función <a href="http://es.wikipedia.org/wiki/Arcotangente">arcotangente</a> (abreviada $atan$), que a su vez es la inversa de la función <a href="http://es.wikipedia.org/wiki/Tangente_(trigonometr%C3%ADa)">tangente</a> (abreviada $tan$ o $tg$).</p><p>La función tangente de un ángulo se define como la división de la longitud del cateto opuesto a ese ángulo entre la longitud del cateto contiguo.</p><p>$$tan(\alpha) = \frac{cateto\ opuesto}{cateto\ contiguo}$$</p><p>La arcotangente nos da la información contraria: a partir de la división del cateto opuesto y el cateto contiguo nos da el ángulo.</p><p>$$atan\bigg( \frac{cateto\ opuesto}{cateto\ contiguo} \bigg) = \alpha$$</p><p>La función arcotangente viene implementada en todos los lenguajes de programación de uso común. Sin embargo, tiene un defecto: sólo devuelve ángulos entre -90° y 90°. Esto es debido a que al hacer la división de cateto opuesto entre cateto contiguo estamos perdiendo información. Por ejemplo, basta con que uno de ellos sea negativo para que el resultado sea también negativo, y a partir del resultado no podemos determinar el signo de los operandos.</p><p>Para obtener un ángulo entre 0° y 360° (o lo que es lo mismo entre -180° y 180°) debemos tener en cuenta el signo de los catetos del triángulo. Por ejemplo, si el cateto horizontal es negativo y el vertical es positivo, será necesario sumar 90° al ángulo devuelto por la arcotangente. Además con la función de arcotangente que tener un cuidado especial, ya que si el cateto contiguo es cero se producirá una excepción de división por cero.</p><p>Debido a todos estos casos especiales, y siendo un problema muy habitual necesitar calcular un ángulo a partir de sus catetos, la mayoría de lenguajes de programación implementan una función <code>atan2</code> (<a href="http://en.wikipedia.org/wiki/Atan2#Definition_and_computation">definición en Wikipedia</a>) que recibe en parámetros separados la longitud del cateto opuesto y la longitud del cateto contiguo, encargándose la misma función de ajustar el valor de retorno en función del signo de los argumentos, así como de los valores límite.</p><p>Su uso es muy sencillo. $y$ es la longitud del cateto opuesto (habitualmente altura) y $x$ la del cateto contiguo (habitualmente anchura). Cualquiera de ellos negativos si están al otro lado del origen de coordenadas:</p><p>$$atan2(y, x) = \alpha$$</p><h3 id="Funcion-de-actualizacion"><a href="#Funcion-de-actualizacion" class="headerlink" title="Función de actualización"></a>Función de actualización</h3><p>A continuación se muestra una función de actualización que actualiza la rotación del proyectil durante su trayectoria utilizando el método explicado:</p><pre><code>function update() &#123;    // En este ejemplo asumimos que y=0 es el suelo y las    // y&#39;s positivas están encima del suelo.    // La gravedad modifica la velocidad del objeto,    // siempre que no esté en el suelo.    if (this.y &gt; 0) &#123;        var gravity = 9.8; // píxels/frame²        this.velY = this.velY - gravity;    &#125;    // Movemos el objeto de acuerdo a su velocidad.    this.posX = this.posX + this.velX;    // Utilizamos la función máximo para que el objeto    // no pueda caer a una posición subterránea.    this.posY = Math.max(this.posY + this.velY, 0);    // Actualizamos la rotación del objeto    this.angle = Math.atan2(this.velY, this.velX);&#125;</code></pre>]]></content>
    
    
    <summary type="html">Cómo hacer un pequeño motor de físicas 2D capaz de lanzar proyectiles.</summary>
    
    
    
    <category term="Física" scheme="http://ntrrgc.me/gamematicas/categorias/Fisica/"/>
    
    
    <category term="física" scheme="http://ntrrgc.me/gamematicas/tags/fisica/"/>
    
    <category term="simulación" scheme="http://ntrrgc.me/gamematicas/tags/simulacion/"/>
    
  </entry>
  
  <entry>
    <title>Colocar objetos siguiendo formas geométricas, parte I: Circunferencia</title>
    <link href="http://ntrrgc.me/gamematicas/colocar-objetos-en-formas-geometricas-parte-1-circunferencia/"/>
    <id>http://ntrrgc.me/gamematicas/colocar-objetos-en-formas-geometricas-parte-1-circunferencia/</id>
    <published>2015-02-22T16:37:34.000Z</published>
    <updated>2021-01-02T02:20:30.067Z</updated>
    
    <content type="html"><![CDATA[<p>A veces queremos colocar elementos siguiendo formas geométricas, ya sea para colocar enemigos, crear efectos especiales o como parte de la decoración.<br>En este primer artículo veremos cómo colocar elementos en una circunferencia. En la siguiente parte (¡pronto!) veremos cómo colocar objetos en polígonos y estrellas.</p><h1 id="Repaso-de-trigonometria-la-circunferencia"><a href="#Repaso-de-trigonometria-la-circunferencia" class="headerlink" title="Repaso de trigonometría: la circunferencia"></a>Repaso de trigonometría: la circunferencia</h1><p>En esta gráfica podemos ver una circunferencia de radio 1 (llamada <em>circunferencia unitaria</em> por esta razón) centrada en $(x = 0, y = 0)$.</p><p>Dado cualquier punto de la circunferencia unitaria, podemos trazar una línea desde el centro de la circunferencia hasta él. La inclinación de esta línea respecto a la línea base nos da un ángulo que llamaremos $\alpha$.</p><p>Utilizando el valor de este ángulo, podemos utilizar dos funciones trigonométricas nos dan la posición exacta de un punto:</p><ul><li>Seno: dado un ángulo, devuelve la coordenada $y$ del punto con ese ángulo dentro de la circunferencia unitaria.</li><li>Coseno: dado un ángulo, devuelve la coordenada $x$ del punto con ese ángulo dentro de la circunferencia unitaria.</li></ul><p>Si tenemos una circunferencia cuyo radio no es 1, multiplicaremos las coordenadas obtenidas por el radio. Por ejemplo: en una circunferencia de radio 1, el punto con ángulo 30º es $(0.87, 0.5)$. En una circunferencia de radio 2, ese punto estará en $(1.74, 1)$.</p><p>Las coordenadas devueltas por las funciones seno y coseno asumen que nuestra circunferencia tiene centro en $(0, 0)$. Podemos sumar o restar valores en estas coordenadas para colocar la circunferencia donde queramos.</p><h2 id="Medicion-de-angulos"><a href="#Medicion-de-angulos" class="headerlink" title="Medición de ángulos"></a>Medición de ángulos</h2><p>Hay dos unidades populares para medir ángulos: </p><ul><li>Grados: Un ángulo completo son 360º.</li><li>Radianes: Un ángulo completo es la longitud de una circunferencia unitaria, es decir, $2\pi \approx 6.2831$ rad.</li></ul><p>Las medidas en grados son más fáciles de comunicar numéricamente a personas: es más fácil recordar que un cuarto de circunferencia son 90 grados, que recordar que son 1,5707… radianes. Por otro lado, muchas fórmulas matemáticas son más sencillas si los ángulos están expresados en radianes.</p><p>Distintos lenguajes de programación pueden utilizar diferentes unidades para los ángulos, e incluso dentro del mismo lenguaje puede haber funcionalidades que trabajen en una u otra unidad. Es importante saber con qué unidades trabaja una determinada función antes de utilizarla.</p><p>En cuanto a las funciones trigonométricas habituales (seno, coseno…), la mayoría de lenguajes utilizan radianes como unidad. Convertir ángulos de una unidad a otra es fácil:<br>$$grados\ a\ radianes(grados) = grados\cdot\frac{2\pi}{360}\\<br>radianes\ a\ grados(radianes) = radianes \cdot \frac{360}{2\pi}$$</p><h2 id="Colocar-objetos-alrededor-del-circulo"><a href="#Colocar-objetos-alrededor-del-circulo" class="headerlink" title="Colocar objetos alrededor del círculo"></a>Colocar objetos alrededor del círculo</h2><p>El primer paso que tenemos que tomar es decidir cuántos objetos colocar (<code>num_objetos</code>). Si dividimos 360º o $2\pi$ rad obtendremos un ángulo que nos indicará la separación entre cada objeto, <code>separacion</code>.</p><p>Multiplicaremos <code>separacion</code> por cada número entero entre 0 y <code>num_objetos</code> (no incluido). En cada caso obtendremos el ángulo en el que debemos colocar un objeto. Utilizando las funciones seno y coseno podemos transformar este ángulo en coordenadas $x$ e $y$.</p><pre><code>var tau = 2 * Math.PI;function drawWidgetsAroundCircle(ctx, centerX, centerY,                                 radius, numWidgets)&#123;  var ang_interval = tau / numWidgets;  for (var i = 0; i &lt; numWidgets; i++) &#123;    var x = centerX + Math.cos(ang_interval) * radius;    var y = centerY + Math.sin(ang_interval) * radius;    drawWidget(ctx, x, y);  &#125;&#125;</code></pre><div class="demo" data-demo-name="circle" data-demo-tag="">  <header class="phone">Demostración en vivo</header>  <div class="demo-wrapper">    <div class="canvas-wrapper">      <canvas width="300" height="200"></canvas>    </div>    <noscript>La demostración en vivo no funciona sin JavaScript :(</noscript>    <div class="controls-wrapper">      <header class="non-phone">Demostración en vivo</header>      <div class="demo-controls"></div>    </div>  </div></div>]]></content>
    
    
    <summary type="html">Cómo colocar objetos en forma de círculo en un videojuego.</summary>
    
    
    
    <category term="Geometría" scheme="http://ntrrgc.me/gamematicas/categorias/Geometria/"/>
    
    
    <category term="trigonometría" scheme="http://ntrrgc.me/gamematicas/tags/trigonometria/"/>
    
    <category term="colocación de objetos" scheme="http://ntrrgc.me/gamematicas/tags/colocacion-de-objetos/"/>
    
    <category term="geometría" scheme="http://ntrrgc.me/gamematicas/tags/geometria/"/>
    
  </entry>
  
</feed>
